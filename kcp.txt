1.基本用法
//初始化kcp对象，conv为一个表示会话编号的整数，和tcp的conv一样，通信双
//方需保证conv相同，相互的数据包才能够被认可，用户是给给函数的指针
ikcpcb * kcp = ikcp_create（conv，user）;

// KCP的下层协议输出函数，KCP需要发送数据时会调用它
// ikcp_send中会调用output,在里面处理底层网络发送
// buf / len表示缓存和长度
//用户指针为kcp对象创建时的值，用于区分多个KCP对象
//user同ikcp_create（conv，user）中的user
int  udp_output（ const  char * buf， int len，ikcpcb * kcp， void * user）
{
  ....
}
//设置变量函数
kcp-> output = udp_output;

//以一定频率调用ikcp_update来更新kcp状态，并连接到当前时钟（毫秒单位）
//如10ms调用一次，或用ikcp_check确定再次调用更新的时间不必调用
ikcp_update（kcp，millisec）;

//收到一个下层数据包（一个UDP包）时需要调用：
//将数据输入到kcp中，然后通过ikcp_send来读取
ikcp_input（kcp，received_udp_packet，received_udp_size);


2.基本流程
1.建立upd连接
2.客户端请求建立kcp连接，服务端创建conv标识(uint32_t)调用ikcp_create（conv，user）,然后返回给客户端,调用ikcp_create（conv，user）建立kcp连接
3.ikcp_send、ikcp_recv作为上层发送接受接口,在底层对接upd相应接口
4.用ikcp_send发送数据,kcp处理完后通过output回调调用upd发送数据
5.在upd接受数据，用ikcp_input将数据发送到kcp层，然后通过ikcp_recv读取消息(while (true){ ikcp_recv(...) })